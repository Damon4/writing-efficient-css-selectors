# Как писать эффективные с точки зрения производительности CSS-селекторы

Эффективный с точки зрения производительности CSS — не то чтобы особенно новая тема, и не то чтобы мне особенно нужно написать что-то именно о ней, но она серьезно меня интересует, и я присматривался к ней все больше и больше с тех пор, как работал в Sky.

Очень многие люди забывают — или просто не осознают, — что CSS может быть лучше или хуже с точки с зрения производительности. Впрочем, это можно легко простить, когда вы понимаете, насколько в принципе сложно написать низкопроизводительный CSS.

Все эти правила касаются, в общем-то, только очень посещаемых сайтов, для которых скорость очень важна, и тысячи DOM-элементов могут появиться на каждой конкретной страницы. Но, в конце концов, передовая практика есть передовая практика, и не важно, разрабатываете ли вы второй Facebook или сайт для вашего знакомого дизайнера интерьеров, ее хорошо знать в любом случае.

## CSS-селекторы

В CSS-селекторах для большинства из нас нет ничего нового. Базовые селекторы — это тип (например, *div*), ID (например, *#header*) и класс (например, *.tweet*).

Чуть менее распространенные селекторы: базовые псевдоклассы (например, *:hover*) и более сложные селекторы, из CSS3 или с использованием регулярных выражений: *:first-child* и *[class^="grid-"]*.

У селекторов есть встроенное поведение с точки зрения производительности, и, сославшись на Стива Саудерса (Steve Souders), отсортировать CSS-селекторы от более к менее производительным можно так:

- ID, например: *#header*
- Класс, например: *.promo*
- Тип, например: *div*
- Соседний элемент того же уровня, например: *h2 + p*
- Дочерний элемент, например: *li > ul*
- Вложенный элемент, например: *ul a*
- Общий селектор, например: *
- Атрибут, например: *[type="text"]*
- Псевдоклассы/-элементы, например: *a:hover*

Цитата из книги «Как сделать сайты еще быстрее» (Even Faster Websites) [Стива Саудерса](http://stevesouders.com/)

Важно заметить, что, хотя ID технически быстрее и лучше с точки зрения производительности, эта разница очень невелика. С помощью CSS Test Creator Стива Саудерса можно видеть, что у [селекторов с ID](http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&sel=%23id&body=background%3A+%23CFD&ne=1000) и [селекторов с классом](http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&sel=.class&body=background%3A+%23CFD&ne=1000) в действительности очень маленькая разница во времени перерисовки страницы.

На Firefox 6 под Windows я получил среднее время перерисовки страницы с простым селектором класса в 10.9. То же самое, но с ID-селектором, выдало мне цифру в 12.5, так что на самом деле с ID страница перерисовывалась медленнее, чем с классом.

*Разницы в скорости между ID и классом практически не существует.*

Однако, тест селектора по типу (*<a>*), в отличие от класса или ID, выдал [гораздо большее время перерисовки страницы](http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&sel=a&body=background%3A+%23CFD&ne=1000).

Тест на серьезно перенасыщенном селекторе с вложенными элементами дал [цифру в районе 440](http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&sel=div+div+div+div+div+div+a&body=background%3A+%23CFD&ne=1000)!

Отсюда можно видеть, что разница между ID/классами и типами/вложенными элементами достаточно велика… Разницой же между ними самими можно пренебречь.

*N.B.* Эти цифры могут очень серьезно отличаться на разных компьютерах и разных браузеров. Я настоятельно рекомендую вам потестировать ваш CSS самому.

## Совмещаем селекторы

У вас могут быть независимые селекторы (например, #nav), которые выберут любой элемент с ID ‘nav’, или вы можете поставить в свой документ комбинированные селекторы, например, #nav a, который выберет все ссылки внутри любого элемента с ID ‘nav’.

Итак, мы читаем их слева направо. Мы видим, что мы сперва ищем #nav, а потом — все элементы a внутри него. Браузеры читают селекторы наоборот: справа налево.

Там, где мы видим #nav c a внутри, браузеры видят a внутри #nav. Эта тонкая разница имеет _огромное_ влияние на производительность селекторов, и ее очень важно знать.

Для объяснения внутренних причин, по которым это так, посмотрите вот это обсуждение на [Stack Overflow](http://stackoverflow.com/questions/5797014/css-selectors-parsed-right-to-left-why).

Для браузера гораздо более эффективно с точки зрения производительности начинать с крайнего правого элемента (того, к которому браузер _определенно_ применит стили) и потом подниматься наверх по дереву DOM, чем начинать _наверху_ и потом спускаться по дереву _вниз_, так, что можно вообще не дойти до крайнего правого селектора -- который также называется _ключевым_ селектором.

Это имеет довольно значительное влияние на производительность CSS-селекторов...

## Ключевой селектор

Ключевой селектор, как мы обсуждали — это крайняя правая часть большого CSS-селектора. Это то, на что в первую очередь смотрит браузер.

Помните, мы обсуждали, какие типы селекторов наиболее эффективны с точки зрения производительности? Итак, на производительность селектора в первую очередь влияет ключевой селектор, когда вы пишете быстрый CSS, то именно ключевой селектор является, хм, ключом к производительности CSS.

Такой ключевой селектор:

```#content .intro{}```

Вероятно, достаточно производителен, поскольку классы сами по себе являются производительным селектором. Браузер найдет все элементы .intro (которых, скорее всего, будет немного), а потом пройдет вверх по дереву DOM проверить, находится ли этот ключевой селектор внутри элемента c ID ‘content’.

Однако вот такой селектор совершенно ужасен в плане проивзодительности:

```#content *{}```

Этот селектор делает вот что: смотрит на каждый элемент на страницы (совершенно каждый), а потом смотрит, находятся ли какие-нибудь их них внутри родительского элемента #content. Это очень непроизводительный селектор, поскольку его ключевой селектор является очень дорогим.

Зная это, мы можем принять более продуманные решения с точки зрения назначения классов и выбора элементов.

Предоложим, что у нас есть огромная страница, она гигантским размеров, а еще у нашего сайта огромная посещаемость. На этой странице сотни или даже тысячи <a>. Кроме того, есть маленький раздел со ссылками на социальные сети внутри <ul> с ID #social; давайте предположим, что там идут ссылки на Twitter, Facebook, Dribbble и Google+. Итак, у нас на этой странице четыре ссылки на соцсети и сотни других ссылок.

В таком случае такой селектор будет неразумно дорог и плох в плане производительности:

```#social a{}```

Случится здесь вот что: браузер получит все тысячи ссылок на этой странице и проверит их перед тем, как выбрать четыре ссылки внутри элемента #social. Наш ключевой селектор соответствует слишком большому количеству элементов, которые на самом деле нам не нужны.

Для того, чтобы побороть это, мы можем добавить более явный и специфический селектор -- добавив класс .social-link к каждому из элементов <a> в области #social. Но это идет против того, что нам известно: мы ведь знаем, что не нужно добавить лишние классы к элементам, когда мы можем использовать более чистую разметку с меньшим количеством кода.

Вот почему тема производительности кажется мне настолько интересной: это странный баланс между передовыми практиками веб-стандартов и просто скоростью.

Итак, если обычно мы имели:

```<ul id="social">
    <li><a href="#" class="twitter">Twitter</a></li>
    <li><a href="#" class="facebook">Facebook</a></li>
    <li><a href="#" class="dribble">Dribbble</a></li>
    <li><a href="#" class="gplus">Google+</a></li>
</ul>```

с таким CSS:

```#social a{}```

То теперь мы напишем:

```<ul id="social">
    <li><a href="#" class="social-link twitter">Twitter</a></li>
    <li><a href="#" class="social-link facebook">Facebook</a></li>
    <li><a href="#" class="social-link dribble">Dribbble</a></li>
    <li><a href="#" class="social-link gplus">Google+</a></li>
</ul>```

С таким CSS:

```#social .social-link{}```

Этот новый ключевой селектор будет находить гораздо меньше элементов, что означает, что браузер сможет найти их и отобразить стили быстрее, а потом заняться другими вещами.

И на самом деле мы можем сократить этот селектор еще больше, чтобы он не был перенасыщенным, вплоть до .social-link{}; об этом читайте в следующем разделе…

Итак, повторюсь: ваш ключевой селектор — то, что определяет, сколько работы будет у браузера, так что *обращайте на него внимание*.

## Перенасыщенные селекторы

Итак, теперь мы знаем, что такое ключевой селектор, и что отсюда идет бóльшая часть работы браузера. Теперь мы можем оптимизировать дальше. Самое лучшее в хороших явных ключевых селекторов — что вы можете обойтись без перенасыщенных селекторов. Перенасыщенный селектор выглядит примерно так:

```html body .wrapper #content a{}```

Здесь очень много всего происходит, и по крайней мере три из этих селекторов решительно не нужны. По крайней мере можно было бы написать то же самое так:

```#content a{}```

И что?

Итак, первый по порядку селектор означает, что браузер должен найти все элементы a, затем проверить, что они содержатся в элементе с ID ‘content’ и так далее и так далее вплоть до элемента html. Браузеру приходится из-за этого делать слишком много проверок, которые в действительности не нужны. Зная это, мы можем привести более реалистичные примеры, как такой:

```ul#nav li a{}```

К такому виду:

```#nav a{}```

Мы знаем, что если a находится внутри li, то он должна находиться внутри #nav, так что мы сразу выбрасываем li из селектора. Далее, раз #nav — это ID, который, как мы знаем, существует на странице только в единственном экземпляре, то тип элемента, к которому он применен, абсолютно неважен: значит, мы можем выбросить ul.

Перенасыщенные селекторы заставляют браузеры работать больше, чем это нужно, и занимают драгоценное время. Сделайте ваши селекторы понятнее и быстрее, выбросив из них лишнее.

## Насколько все это необходимо?

Короткий ответ: _не очень_.

Ответ подлинее: _зависит от того, что вы разрабатываете_. Если вы работаете над своим новым портфолио, то пишите чистый код, это важнее, чем производительность CSS-селекторов, которую вы вряд ли когда-либо заметите.

Если вы разрабатываете второй Amazon, где микросекунды в скорости работы страницы имеют значение, то — может быть, хотя и в этом случае, может быть, это и возможно проигнорировать.

Браузеры (даже мобильные браузеры) станут парсить CSS только быстрее. Вы очень вряд ли когда-либо заметите на сайте медленные CSS-селекторы, *но*…

## Но

Тем не менее все это еще происходит, браузерам все равно приходится делать ту работу, о которой мы говорили, какими бы быстрыми они ни становились. Даже если вам не нужно (или даже вы не хотите) применять что-либо из описанного здесь, в любом случае это определенно следует знать. Держите в уме, что селекторы могут быть дорогими в плане производительности, и по крайней мере самых зубодробительных вам стоит по возможности избегать. То есть если внезапно вы ловите себя на том, что пишете что-то такое:

```div:nth-of-type(3) ul:last-child li:nth-of-type(odd) *{ font-weight:bold }```

То, наверное, вы делаете что-то неправильно.

Я сам все еще относительный новичок в мире производительности CSS-селекторов, так что если я что-то пропустил или вам есть что добавить, пожалуйста, пишите в комментах!

## Еще о эффективности CSS-селекторов с точки зрения производительности

Я неустанно рекомендую сайти и книги [Стива Саудерса](http://stevesouders.com/). Это практически единственная рекомендация для _дальнейшего чтения_, и она вам реально пригодится. Парень знает свою тему!